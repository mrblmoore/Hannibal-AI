We are upgrading the HannibalAI mod for Mount & Blade II: Bannerlord with the following features.

ğŸ“ Existing Codebase Overview:
âœ… AICommander.cs â†’ handles formation commands (Move, Hold, Flank, Charge, etc.)
âœ… BattleController.cs â†’ routes decisions to AICommander
âœ… AIService.cs â†’ builds decisions per battle snapshot
âœ… FallbackService.cs â†’ handles fallback decisions
âœ… CommanderMemoryService.cs â†’ tracks basic commander memory
âœ… Logger.cs â†’ file/debug logging
âœ… ModConfig.cs â†’ config settings
âœ… SubModule.xml â†’ registered

ğŸ¯ NEW FEATURES + REQUIRED IMPLEMENTATIONS:
ğŸŸ¢ 1ï¸âƒ£ COMPLETE UI (ModSettingsView.cs):
We need a fully working in-game UI using GauntletUI (or your recommended method):

âœ… A new UI tab or popup for HannibalAI config â†’ accessible in campaign or custom battle.
âœ… Connect UI controls to ModConfig fields:

Toggle: AIControlsEnemies (true/false)

Toggle: UseCommanderMemory (true/false)

Toggle: Debug (true/false)

Slider: Aggressiveness (0-100)

âš ï¸ Ensure ViewModel binds these fields â†’ reflect + persist changes.

â¡ï¸ UI should read/update ModConfig.Instance at runtime.

ğŸŸ¢ 2ï¸âƒ£ ALLOW AI TO CONTROL ENEMY TEAM:
âœ… Add a new setting in ModConfig.cs:

csharp
Copy
Edit
public bool AIControlsEnemies { get; set; } = false;
âœ… In BattleController.cs â†’ ExecuteAIDecision():

Check formation team:

csharp
Copy
Edit
if (formation.Team.IsEnemyOf(Mission.MainAgent.Team) && !ModConfig.Instance.AIControlsEnemies)
    return; // skip enemy AI if toggle off
âœ… If toggle enabled â†’ process decisions for enemy formations too.

ğŸŸ¢ 3ï¸âƒ£ EXPAND AI TACTICAL LOGIC:
âœ… In AIService.cs, add new helper methods:

csharp
Copy
Edit
bool IsEnemyNearby(Formation formation);
bool IsAllyFormationWeak(Formation formation);
bool IsTerrainAdvantageous(Vec3 position);
â¡ï¸ Implement realistic checks using Bannerlord API (distance, health %, terrain tags).

âœ… Update ProcessBattleSnapshot() to use these for decision logic:

Example:

csharp
Copy
Edit
if (IsEnemyNearby(f) && IsAllyFormationWeak(f))
    command = new HoldCommand { Formation = f.Index, HoldPosition = f.CurrentPosition };
else if (IsTerrainAdvantageous(f.CurrentPosition))
    command = new FlankCommand { Formation = f.Index, TargetPosition = flankPos };
else
    command = new ChargeCommand { Formation = f.Index };
â¡ï¸ Allow AI to respond to proximity, ally status, terrain advantage.

ğŸŸ¢ 4ï¸âƒ£ FINISH COMMANDERMEMORYSERVICE:
âœ… Add properties to CommanderMemoryService.cs:

csharp
Copy
Edit
public int TimesDefeatedPlayer { get; set; }
public string PreferredFormation { get; set; }
public float AggressivenessScore { get; set; }
public bool HasVendettaAgainstPlayer { get; set; }
âœ… Implement file save/load â†’ JSON preferred:

csharp
Copy
Edit
public void SaveToFile(string path);
public void LoadFromFile(string path);
â¡ï¸ Memory must persist between game sessions.

âœ… On battle end, increment TimesDefeatedPlayer if defeated, etc. â†’ auto-save.

âœ… Read memory in AIService â†’ adjust behavior dynamically:

csharp
Copy
Edit
if (CommanderMemoryService.Instance.HasVendettaAgainstPlayer)
    targetPlayerFormationMore();
ğŸŸ¢ 5ï¸âƒ£ ADD BASIC NEMESIS SYSTEM:
âœ… If player defeats same enemy commander 3+ times:

â†’ Commander gets title: "The Stubborn", "The Cunning", etc.

âœ… Store commander nickname in CommanderMemoryService.

âœ… Nemesis AI tracks:

Player defeats vs. that commander

Player kills by commander

Aggression tuning (increase if confident, retreat if low morale)

âœ… Use memory to modify fallback decisions:

csharp
Copy
Edit
if (CommanderMemoryService.Instance.TimesDefeatedPlayer >= 3)
    preferFlankingOverCharge = true;
âœ… Optionally display nemesis name on UI (future integration).

ğŸŸ¢ 6ï¸âƒ£ ENSURE CONSISTENT INTEGRATION:
âœ… Any new fields/methods must be reflected in:

ModConfig.cs

SubModule.xml

UI ViewModel bindings

Runtime initializations

âœ… Cross-check namespace consistency:

HannibalAI.Battle

HannibalAI.Command

HannibalAI.Services

HannibalAI.Config

HannibalAI.Utils

HannibalAI.UI

âœ… Confirm all public methods have at least 1 reference â†’ no dead code.

âš ï¸ IMPLEMENTATION NOTES:
â¡ï¸ Avoid using fake Bannerlord API calls.
â¡ï¸ Use only documented TaleWorlds.Engine, TaleWorlds.MountAndBlade, TaleWorlds.GauntletUI namespaces.
â¡ï¸ Use Vec3 from TaleWorlds.Library.
â¡ï¸ Ensure Logger uses consistent file path (relative to module dir or save folder).

ğŸ”¥ DELIVERABLES:
âœ… Updated UI with working toggles/sliders.

âœ… AI controls enemy team if toggle enabled.

âœ… Tactical inputs + smarter AIService decisions.

âœ… CommanderMemoryService fully implemented & persists.

âœ… Nemesis system (titles, vendetta, dynamic behaviors).

âœ… All new methods/fields properly wired & referenced.

âœ… Compiles cleanly â†’ no build errors/warnings.

ğŸ“ For Replit:
â¡ï¸ "This is an existing C# Bannerlord mod project in Visual Studio.
I need you to complete these features without breaking current functionality.
Integrate using best practices for Bannerlord modding.
Donâ€™t hallucinate API calls â€” verify via existing TaleWorlds API."